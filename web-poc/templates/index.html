<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>JPG to G4 Upload</title>
    <style>
      body { font-family: system-ui, sans-serif; background: #f6f7fb; margin: 0; }
      .container { max-width: 720px; margin: 40px auto; background: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); }
      h1 { margin-top: 0; }
      label { display: block; font-weight: 600; margin-top: 16px; }
      select, input[type="file"] { width: 100%; margin-top: 6px; padding: 8px; }
      button { margin-top: 20px; padding: 10px 16px; font-weight: 600; }
      .message { background: #e6f6ea; color: #1f7a3f; padding: 10px; border-radius: 8px; margin-top: 16px; }
      .error { background: #fdecea; color: #a12f2f; padding: 10px; border-radius: 8px; margin-top: 16px; }
      .muted { color: #6b7280; font-size: 0.9rem; }
      .preview { margin-top: 16px; text-align: center; }
      .preview img { max-width: 50%; border-radius: 8px; border: 1px solid #e5e7eb; }
      h2 { margin-top: 28px; }
      table { width: 100%; border-collapse: collapse; margin-top: 12px; }
      th, td { text-align: left; padding: 10px; border-top: 1px solid #e5e7eb; vertical-align: middle; }
      th { font-size: 0.9rem; color: #374151; background: #f9fafb; }
      .btn-sm { padding: 6px 10px; margin: 0; font-size: 0.85rem; }
      .btn-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .panel { border: 1px solid #e5e7eb; background: #fbfcff; border-radius: 12px; padding: 14px; margin-top: 12px; }
      .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
      @media (min-width: 720px) { .grid { grid-template-columns: 1fr 1fr; } }
      dialog { border: 1px solid #e5e7eb; border-radius: 12px; padding: 0; width: min(900px, 92vw); }
      dialog::backdrop { background: rgba(0,0,0,0.35); }
      .dialog-head { padding: 12px 14px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; gap: 10px; align-items: center; }
      .dialog-body { padding: 12px 14px; }
      pre { white-space: pre-wrap; word-break: break-word; margin: 0; font-size: 0.85rem; background: #0b1020; color: #e5e7eb; padding: 12px; border-radius: 10px; overflow: auto; max-height: 65vh; }
      .thumb-wrap { width: 56px; height: 56px; border-radius: 10px; border: 1px solid #e5e7eb; background: #f3f4f6; overflow: hidden; }
      .thumb { width: 56px; height: 56px; border-radius: 10px; border: 1px solid #e5e7eb; background: #f3f4f6; object-fit: cover; }
      .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 0.8rem; border: 1px solid #e5e7eb; background: #fff; color: #374151; }
      .badge.temporary { border-color: #f59e0b; }
      .badge.permanent { border-color: #3b82f6; }
      .badge.state.queued { border-color: #8b5cf6; }
      .badge.state.ondevice { border-color: #10b981; }
      .badge.expired { border-color: #ef4444; color: #991b1b; background: #fdecea; }
      .row-meta { color: #6b7280; font-size: 0.85rem; }
      .row-name { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.85rem; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Upload JPG → G4</h1>
      <p class="muted">User: {{ user or "anonymous" }}</p>

      <div id="error" class="error" style="display: none;"></div>
      <div id="message" class="message" style="display: none;"></div>

      {% if devices and devices|length > 0 %}
        <form id="upload-form" action="/upload" method="post" enctype="multipart/form-data">
          <label for="device_id">Device</label>
          <select id="device_id" name="device_id" required>
            {% for d in devices %}
              <option value="{{ d.id }}">{{ d.id }}</option>
            {% endfor %}
          </select>

          <label for="queue">Queue</label>
          <select id="queue" name="queue" required>
            <option value="queue-permanent" selected>Permanent (queue-permanent/)</option>
            <option value="queue-temporary">Temporary (queue-temporary/)</option>
          </select>

          <div id="ttl-wrapper" style="display: none;">
            <label for="ttl_hours">Temp TTL (hours)</label>
            <input id="ttl_hours" name="ttl_hours" type="number" min="1" max="720" value="24" />
            <div class="muted">Expires after upload + TTL. Max 720h.</div>
          </div>

          <label for="file">JPG file</label>
          <input id="file" name="file" type="file" accept=".jpg,.jpeg,image/jpeg" required />

          <label for="caption">Caption (optional)</label>
          <input id="caption" name="caption" type="text" maxlength="120" placeholder="e.g. Sunset in Porto" />

          <label for="progress">Progress</label>
          <progress id="progress" value="0" max="100" style="width: 100%;"></progress>
          <div id="status" class="muted" style="margin-top: 6px;">Idle</div>

          <button type="submit">Upload</button>

          <div id="preview" class="preview" style="display: none;">
            <img id="preview-img" alt="Uploaded preview" />
          </div>
        </form>

        <h2>Device twin</h2>
        <div class="muted">Shows queue blobs (<span class="row-name">queue-temporary/</span>, <span class="row-name">queue-permanent/</span>) plus truth store previews (<span class="row-name">all/temporary</span>, <span class="row-name">all/permanent</span>) in one deduplicated list. “On device” means: present in <span class="row-name">all/</span> but not currently queued. Thumbnails/meta are proxied by this web-poc (no SAS in the browser).</div>
        <button id="refresh" type="button" style="margin-top: 10px;">Refresh</button>
        <div id="twin-error" class="error" style="display: none;"></div>
        <table>
          <colgroup>
            <col style="width: 70px;" />
            <col />
            <col style="width: 140px;" />
            <col style="width: 170px;" />
            <col style="width: 140px;" />
            <col style="width: 170px;" />
          </colgroup>
          <thead>
            <tr>
              <th>Preview</th>
              <th>Caption</th>
              <th>Uploaded by</th>
              <th>State</th>
              <th>Expires in</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="twin-body">
            <tr><td colspan="6" class="muted">Idle</td></tr>
          </tbody>
        </table>

        <h2>Commands</h2>
        <div class="muted">Queue commands for the selected device. Commands remain <b>Queued</b> until the device processes them and deletes the command blob.</div>

        <div class="grid">
          <div class="panel">
            <div class="muted" style="margin-bottom: 10px;"><b>Device actions</b></div>
            <div class="btn-row">
              <button id="cmd-resync" type="button" class="btn-sm">Re-sync From Cloud</button>
              <button id="cmd-reboot" type="button" class="btn-sm">Reboot Device</button>
              <button id="cmd-config-portal" type="button" class="btn-sm">Enable Config Portal</button>
            </div>

            <div style="margin-top: 12px;">
              <label for="rotation-seconds">Rotation interval (seconds)</label>
              <input id="rotation-seconds" type="number" min="10" max="86400" value="3600" />
              <div class="btn-row" style="margin-top: 8px;">
                <button id="cmd-rotation" type="button" class="btn-sm">Set Rotation Interval</button>
              </div>
            </div>

            <div style="margin-top: 12px;">
              <div class="muted" style="margin-bottom: 8px;"><b>Destructive</b></div>
              <button id="cmd-clean-all" type="button" class="btn-sm" style="background:#fdecea; border:1px solid #ef4444;">Clean All Content</button>
              <div class="muted" style="margin-top: 6px;">Deletes everything on SD and in the blob container (contents only; does not delete the container). Config stays.</div>
            </div>
          </div>

          <div class="panel">
            <div class="btn-row" style="justify-content: space-between;">
              <div class="muted"><b>Queued commands</b></div>
              <button id="refresh-commands" type="button" class="btn-sm">Refresh</button>
            </div>
            <div id="commands-error" class="error" style="display:none; margin-top:10px;"></div>
            <table>
              <colgroup>
                <col style="width: 170px;" />
                <col style="width: 140px;" />
                <col />
                <col style="width: 110px;" />
              </colgroup>
              <thead>
                <tr>
                  <th>Created</th>
                  <th>Op</th>
                  <th>Blob</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="commands-body">
                <tr><td colspan="4" class="muted">Idle</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <dialog id="json-dialog">
          <div class="dialog-head">
            <div>
              <div style="font-weight: 700;">Command JSON</div>
              <div id="json-dialog-sub" class="muted" style="margin-top: 2px;"></div>
            </div>
            <div class="btn-row">
              <button id="json-copy" type="button" class="btn-sm">Copy</button>
              <button id="json-close" type="button" class="btn-sm">Close</button>
            </div>
          </div>
          <div class="dialog-body">
            <pre id="json-pre">Loading...</pre>
          </div>
        </dialog>
      {% endif %}
    </div>
    <script>
      const form = document.getElementById('upload-form');
      const progress = document.getElementById('progress');
      const statusLabel = document.getElementById('status');
      const errorBox = document.getElementById('error');
      const messageBox = document.getElementById('message');
      const fileInput = document.getElementById('file');
      const queueSelect = document.getElementById('queue');
      const deviceSelect = document.getElementById('device_id');
      const ttlWrapper = document.getElementById('ttl-wrapper');
      const preview = document.getElementById('preview');
      const previewImg = document.getElementById('preview-img');
      const refreshBtn = document.getElementById('refresh');
      const twinBody = document.getElementById('twin-body');
      const twinError = document.getElementById('twin-error');
      const refreshCommandsBtn = document.getElementById('refresh-commands');
      const commandsBody = document.getElementById('commands-body');
      const commandsError = document.getElementById('commands-error');
      const cmdResync = document.getElementById('cmd-resync');
      const cmdReboot = document.getElementById('cmd-reboot');
      const cmdConfigPortal = document.getElementById('cmd-config-portal');
      const cmdRotation = document.getElementById('cmd-rotation');
      const rotationSeconds = document.getElementById('rotation-seconds');
      const cmdCleanAll = document.getElementById('cmd-clean-all');
      const jsonDialog = document.getElementById('json-dialog');
      const jsonPre = document.getElementById('json-pre');
      const jsonClose = document.getElementById('json-close');
      const jsonCopy = document.getElementById('json-copy');
      const jsonDialogSub = document.getElementById('json-dialog-sub');

      let lastJsonText = '';

      function resetMessages() {
        errorBox.style.display = 'none';
        messageBox.style.display = 'none';
        errorBox.textContent = '';
        messageBox.textContent = '';
      }

      function updateTtlVisibility() {
        if (!queueSelect || !ttlWrapper) return;
        if (queueSelect.value === 'queue-temporary') {
          ttlWrapper.style.display = 'block';
        } else {
          ttlWrapper.style.display = 'none';
        }
      }

      function esc(text) {
        const span = document.createElement('span');
        span.textContent = text;
        return span.innerHTML;
      }

      function setTwinError(msg) {
        if (!twinError) return;
        if (msg) {
          twinError.textContent = msg;
          twinError.style.display = 'block';
        } else {
          twinError.textContent = '';
          twinError.style.display = 'none';
        }
      }

      function setCommandsError(msg) {
        if (!commandsError) return;
        if (msg) {
          commandsError.textContent = msg;
          commandsError.style.display = 'block';
        } else {
          commandsError.textContent = '';
          commandsError.style.display = 'none';
        }
      }

      async function enqueueCommand(op, args) {
        resetMessages();
        setCommandsError(null);
        const deviceId = deviceSelect ? deviceSelect.value : '';
        if (!deviceId) throw new Error('No device selected');

        const res = await fetch('/api/commands/enqueue', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ device_id: deviceId, op, args: args || {} }),
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || data.status !== 'ok') {
          throw new Error(data.error || `Enqueue failed (status ${res.status})`);
        }
        messageBox.textContent = `Queued: ${data.blob || op}`;
        messageBox.style.display = 'block';
        await refreshCommands();
      }

      async function refreshCommands() {
        if (!deviceSelect || !commandsBody) return;
        setCommandsError(null);
        commandsBody.innerHTML = '<tr><td colspan="4" class="muted">Loading...</td></tr>';

        const deviceId = deviceSelect.value;
        try {
          const res = await fetch(`/api/commands?device_id=${encodeURIComponent(deviceId)}`);
          const data = await res.json();
          if (!res.ok || data.status !== 'ok') {
            throw new Error(data.error || `List failed (status ${res.status})`);
          }

          const cmds = Array.isArray(data.commands) ? data.commands : [];
          if (cmds.length === 0) {
            commandsBody.innerHTML = '<tr><td colspan="4" class="muted">No queued commands</td></tr>';
            return;
          }

          commandsBody.innerHTML = cmds.map(c => {
            const created = c.created_at_utc ? esc(c.created_at_utc) : '—';
            const op = c.op ? esc(c.op) : '—';
            const blob = c.blob ? esc(c.blob) : '—';
            const viewBtn = c.blob ? `<button type="button" class="btn-sm cmd-view" data-blob="${esc(c.blob)}">View</button>` : '';
            const delBtn = c.blob ? `<button type="button" class="btn-sm cmd-cancel" data-blob="${esc(c.blob)}">Delete</button>` : '';
            return `
              <tr>
                <td><span class="row-meta">${created}</span></td>
                <td><span class="row-name">${op}</span></td>
                <td><span class="row-name">${blob}</span></td>
                <td><div class="btn-row">${viewBtn}${delBtn}</div></td>
              </tr>
            `;
          }).join('');

          for (const btn of commandsBody.querySelectorAll('.cmd-view')) {
            btn.addEventListener('click', async () => {
              const blob = btn.getAttribute('data-blob');
              if (!blob) return;

              const deviceId = deviceSelect.value;
              setCommandsError(null);
              lastJsonText = '';

              if (jsonDialogSub) jsonDialogSub.textContent = blob;
              if (jsonPre) jsonPre.textContent = 'Loading...';
              if (jsonDialog && typeof jsonDialog.showModal === 'function') {
                jsonDialog.showModal();
              }

              try {
                const url = `/api/commands/read?device_id=${encodeURIComponent(deviceId)}&blob=${encodeURIComponent(blob)}`;
                const res = await fetch(url);
                const text = await res.text();
                if (!res.ok) {
                  throw new Error(text || `Read failed (status ${res.status})`);
                }
                let pretty = text;
                try {
                  const obj = JSON.parse(text);
                  pretty = JSON.stringify(obj, null, 2);
                } catch {
                  // keep raw
                }
                lastJsonText = pretty;
                if (jsonPre) jsonPre.textContent = pretty;
              } catch (e) {
                const msg = String(e);
                lastJsonText = msg;
                if (jsonPre) jsonPre.textContent = msg;
              }
            });
          }

          for (const btn of commandsBody.querySelectorAll('.cmd-cancel')) {
            btn.addEventListener('click', async () => {
              const blob = btn.getAttribute('data-blob');
              if (!blob) return;
              if (!confirm(`Delete queued command?\n\n${blob}`)) return;
              try {
                const deviceId = deviceSelect.value;
                const res = await fetch('/api/commands/delete', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ device_id: deviceId, blob }),
                });
                const data = await res.json().catch(() => ({}));
                if (!res.ok || data.status !== 'ok') {
                  throw new Error(data.error || `Delete failed (status ${res.status})`);
                }
                await refreshCommands();
              } catch (e) {
                setCommandsError(String(e));
              }
            });
          }
        } catch (e) {
          setCommandsError(String(e));
          commandsBody.innerHTML = '<tr><td colspan="4" class="muted">Failed</td></tr>';
        }
      }

      if (jsonClose && jsonDialog) {
        jsonClose.addEventListener('click', () => jsonDialog.close());
      }
      if (jsonCopy) {
        jsonCopy.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(lastJsonText || '');
          } catch {
            // ignore
          }
        });
      }

      function formatDuration(ms) {
        if (ms <= 0) return 'Expired';
        const totalMinutes = Math.floor(ms / 60000);
        if (totalMinutes <= 0) return '<1min';

        const days = Math.floor(totalMinutes / (60 * 24));
        const hours = Math.floor((totalMinutes - days * 60 * 24) / 60);
        const minutes = totalMinutes % 60;

        const parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0) parts.push(`${minutes}min`);

        // Keep it compact: show at most 2 parts.
        return parts.slice(0, 2).join(', ');
      }

      function computeExpiresIn(expiresAtUtc) {
        if (!expiresAtUtc) return null;
        const t = Date.parse(expiresAtUtc);
        if (Number.isNaN(t)) return null;
        const now = Date.now();
        return formatDuration(t - now);
      }

      async function fetchMeta(deviceId, g4Name) {
        const url = `/meta?device_id=${encodeURIComponent(deviceId)}&name=${encodeURIComponent(g4Name)}`;
        const res = await fetch(url);
        if (!res.ok) return null;
        try {
          return await res.json();
        } catch {
          return null;
        }
      }

      async function refreshTwin() {
        if (!deviceSelect || !twinBody) return;
        setTwinError(null);
        twinBody.innerHTML = '<tr><td colspan="6" class="muted">Loading...</td></tr>';

        const deviceId = deviceSelect.value;
        try {
          const res = await fetch(`/api/list?device_id=${encodeURIComponent(deviceId)}`);
          const data = await res.json();
          if (!res.ok || data.status !== 'ok') {
            throw new Error(data.error || `List failed (status ${res.status})`);
          }

          // New API: merged items list.
          // Fallback to legacy perm/temp fields if items isn't present.
          const rows = Array.isArray(data.items) ? data.items.map(it => ({
            name: it.name,
            queue: it.queue,
            queued: !!it.queued,
            archived: !!it.archived,
            on_device: (typeof it.on_device === 'boolean') ? it.on_device : (!!it.archived && !it.queued),
            expires_at_utc: it.expires_at_utc || null,
            expired: (typeof it.expired === 'boolean') ? it.expired : null,
          })) : (() => {
            const legacy = [];
            for (const item of (data.temp || [])) {
              legacy.push({
                name: item.name,
                queue: 'temporary',
                queued: true,
                archived: false,
                expires_at_utc: item.expires_at_utc,
                expired: item.expired,
              });
            }
            for (const item of (data.perm || [])) {
              legacy.push({ name: item.name, queue: 'permanent', queued: true, archived: false, expires_at_utc: null, expired: null });
            }
            return legacy;
          })();

          if (rows.length === 0) {
            twinBody.innerHTML = '<tr><td colspan="6" class="muted">No items</td></tr>';
            return;
          }

          twinBody.innerHTML = rows.map(r => {
            const thumbUrl = `/thumb?device_id=${encodeURIComponent(deviceId)}&name=${encodeURIComponent(r.name)}`;

            const scopeLabel = (r.queue === 'temporary') ? 'Temporary' : 'Permanent';
            const scopeBadge = `<span class="badge ${r.queue}">${scopeLabel}</span>`;

            let stateBadge = '<span class="row-meta">—</span>';
            if (r.queued) {
              stateBadge = '<span class="badge state queued">Queued</span>';
            } else if (r.on_device || r.archived) {
              stateBadge = '<span class="badge state ondevice">On device</span>';
            }

            const stateHtml = `<div style="display:flex; gap:6px; flex-wrap:wrap;">${scopeBadge}${stateBadge}</div>`;

            let expiresIn = '<span class="muted">—</span>';
            if (r.queue === 'temporary') {
              const remaining = computeExpiresIn(r.expires_at_utc);
              if (remaining) {
                expiresIn = r.expired ? `<span class="badge expired">Expired</span>` : `<span class="row-meta">${esc(remaining)}</span>`;
              } else {
                expiresIn = '<span class="row-meta">(unknown)</span>';
              }
            }

            // We'll fetch caption/original filename via /meta after initial render.
            const captionHtml = `<span class="row-name" data-meta-name="${esc(r.name)}">${esc(r.name)}</span>`;
            const uploaderHtml = `<span class="row-meta" data-meta-uploader="${esc(r.name)}">—</span>`;

            const actionsHtml = `
              <div class="btn-row">
                <button type="button" class="btn-sm cmd-delete" data-name="${esc(r.name)}">Delete</button>
                <button type="button" class="btn-sm cmd-show-next" data-name="${esc(r.name)}">Show Next</button>
              </div>
            `;

            return `
              <tr>
                <td><div class="thumb-wrap"><img class="thumb" src="${thumbUrl}" loading="lazy" decoding="async" alt="thumb" onerror="this.style.display='none'" /></div></td>
                <td><div>${captionHtml}</div></td>
                <td><div>${uploaderHtml}</div></td>
                <td>${stateHtml}</td>
                <td>${expiresIn}</td>
                <td>${actionsHtml}</td>
              </tr>
            `;
          }).join('');

          // Wire per-row action buttons.
          for (const btn of twinBody.querySelectorAll('.cmd-delete')) {
            btn.addEventListener('click', async () => {
              const name = btn.getAttribute('data-name');
              if (!name) return;
              if (!confirm(`Queue delete for ${name}?`)) return;
              try {
                await enqueueCommand('delete_photo', { path: name });
              } catch (e) {
                errorBox.textContent = String(e);
                errorBox.style.display = 'block';
              }
            });
          }
          for (const btn of twinBody.querySelectorAll('.cmd-show-next')) {
            btn.addEventListener('click', async () => {
              const name = btn.getAttribute('data-name');
              if (!name) return;
              const raw = prompt('Duration seconds (optional, blank = configured interval):', '');
              const args = { path: name };
              if (raw && raw.trim()) {
                const n = Number(raw.trim());
                if (!Number.isFinite(n) || n % 1 !== 0) {
                  alert('Duration must be an integer.');
                  return;
                }
                args.duration_seconds = n;
              }
              try {
                await enqueueCommand('show_next', args);
              } catch (e) {
                errorBox.textContent = String(e);
                errorBox.style.display = 'block';
              }
            });
          }

          // Populate captions from meta JSON (best-effort).
          const captionSpans = twinBody.querySelectorAll('[data-meta-name]');
          const uploaderSpans = twinBody.querySelectorAll('[data-meta-uploader]');
          const metaCache = new Map();
          for (const el of [...captionSpans, ...uploaderSpans]) {
            const g4Name = el.getAttribute('data-meta-name') || el.getAttribute('data-meta-uploader');
            if (!g4Name) continue;

            // Fetch at most once per name.
            if (!metaCache.has(g4Name)) {
              metaCache.set(g4Name, fetchMeta(deviceId, g4Name));
            }
          }
          for (const el of captionSpans) {
            const g4Name = el.getAttribute('data-meta-name');
            if (!g4Name) continue;
            try {
              const meta = await metaCache.get(g4Name);
              if (!meta) continue;
              const caption = (meta.caption || '').trim();
              const original = (meta.original_filename || '').trim();
              el.textContent = caption || original || g4Name;
            } catch {
              // ignore
            }
          }

          for (const el of uploaderSpans) {
            const g4Name = el.getAttribute('data-meta-uploader');
            if (!g4Name) continue;
            try {
              const meta = await metaCache.get(g4Name);
              if (!meta) continue;
              const uploader = (meta.uploader || '').trim();
              el.textContent = uploader || '—';
            } catch {
              // ignore
            }
          }
        } catch (e) {
          setTwinError(String(e));
          twinBody.innerHTML = '<tr><td colspan="6" class="muted">Failed</td></tr>';
        }
      }

      if (form) {
        updateTtlVisibility();
        if (queueSelect) {
          queueSelect.addEventListener('change', updateTtlVisibility);
        }
        form.addEventListener('submit', (event) => {
          event.preventDefault();
          resetMessages();

          const formData = new FormData(form);
          const xhr = new XMLHttpRequest();
          xhr.open('POST', '/upload');
          xhr.responseType = 'json';

          progress.value = 0;
          statusLabel.textContent = 'Uploading...';

          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const percent = Math.round((e.loaded / e.total) * 100);
              progress.value = percent;
            }
          };

          xhr.upload.onloadend = () => {
            progress.value = 100;
            statusLabel.textContent = 'Converting + uploading...';
          };

          xhr.onerror = () => {
            statusLabel.textContent = 'Failed';
            errorBox.textContent = 'Network error during upload.';
            errorBox.style.display = 'block';
          };

          xhr.onload = () => {
            const data = xhr.response || {};
            if (xhr.status >= 200 && xhr.status < 300 && data.status === 'ok') {
              statusLabel.textContent = 'Done';
              messageBox.textContent = data.message || 'Uploaded.';
              messageBox.style.display = 'block';

              const deviceId = deviceSelect ? deviceSelect.value : '';
              if (data.g4_path && deviceId) {
                previewImg.src = `/thumb?device_id=${encodeURIComponent(deviceId)}&name=${encodeURIComponent(data.g4_path)}`;
                preview.style.display = 'block';
              }

              refreshTwin();
              form.reset();
            } else {
              statusLabel.textContent = 'Failed';
              errorBox.textContent = data.error || `Upload failed (status ${xhr.status}).`;
              errorBox.style.display = 'block';
            }
          };

          xhr.send(formData);
        });

        fileInput.addEventListener('change', () => {
          if (fileInput.files && fileInput.files[0]) {
            const objectUrl = URL.createObjectURL(fileInput.files[0]);
            previewImg.src = objectUrl;
            preview.style.display = 'block';
          }
        });

        if (refreshBtn) {
          refreshBtn.addEventListener('click', refreshTwin);
        }
        if (refreshCommandsBtn) {
          refreshCommandsBtn.addEventListener('click', refreshCommands);
        }
        if (deviceSelect) {
          deviceSelect.addEventListener('change', () => {
            refreshTwin();
            refreshCommands();
          });
        }

        if (cmdResync) {
          cmdResync.addEventListener('click', async () => {
            try { await enqueueCommand('resync_from_cloud', {}); } catch (e) { setCommandsError(String(e)); }
          });
        }
        if (cmdReboot) {
          cmdReboot.addEventListener('click', async () => {
            if (!confirm('Queue reboot?')) return;
            try { await enqueueCommand('reboot_device', {}); } catch (e) { setCommandsError(String(e)); }
          });
        }
        if (cmdConfigPortal) {
          cmdConfigPortal.addEventListener('click', async () => {
            if (!confirm('Queue: enable config portal?')) return;
            try { await enqueueCommand('enable_config_portal', {}); } catch (e) { setCommandsError(String(e)); }
          });
        }
        if (cmdRotation) {
          cmdRotation.addEventListener('click', async () => {
            const val = rotationSeconds ? rotationSeconds.value : '';
            const n = Number(val);
            if (!Number.isFinite(n) || n % 1 !== 0) {
              setCommandsError('Rotation interval must be an integer.');
              return;
            }
            try { await enqueueCommand('set_rotation_interval', { seconds: n }); } catch (e) { setCommandsError(String(e)); }
          });
        }
        if (cmdCleanAll) {
          cmdCleanAll.addEventListener('click', async () => {
            const typed = prompt('Type CLEAN ALL to confirm:');
            if (typed !== 'CLEAN ALL') return;
            try { await enqueueCommand('clean_all_content', {}); } catch (e) { setCommandsError(String(e)); }
          });
        }

        refreshTwin();
        refreshCommands();
      }
    </script>
  </body>
</html>
